# 42 Philosophers
----

![](https://cdn.codegym.cc/images/article/4c00491f-3890-4989-85bb-4533c33c7750/800.webp)
Dinning Philoshophers problem is created by Edsger Wybe Dijkstra in 1965 to explain the deadlock state of an operating system, which is traditionally and also commonly introduced in lectures on operating systems.

The problem is that N philosophers are sitting at a round table and eating. A fork is placed between the philosophers, and the philosophers eat through the following process.

Each Philosophers repeats three actions
`1.thinking -> 2.eating -> 3.sleeping`


To `eat`, each philosopher needs to use two forks for both hands. When two forks are lifted, `eating` begins. After a certain amount of time, *provided by argc*, the philosopher puts down both forks respectively, and when both forks are retrieved, the `eating state` switches to a `sleeping state`. When `sleeping state` initiate, philosopher sleeps certain amount of time, *also provided by argc*. After that there are two possible state transition. 

The first one is transit to `eating state`, This occurs when the forks on both sides of the philosopher are available. If not, that means identically when can't use both forks, the philosopher should wait until extra forks are available. This is `thinking state`.

The problem is that if all the philosophers were hungry and picked up the left forks at the same time, the right forks would have already been picked up by the philosopher sitting to their right, and everyone would be forever unable to hold the right forks. That is, there is no further progress, and the philosophers remain on standby forever. This phenomenon is called deadlock. Once in a deadlock, philosophers continue to suffer and die of starvation. Not a single philosopher should die due to a lack of food for a certain period of time. Our goal is implement a program that solves this problem using `mutex` or `semapore`

| External functs.      |                                                                                                                                                                       Description                                                                                                                                                                      |                                                   Form                                                   |         Header         |
|-----------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|:--------------------------------------------------------------------------------------------------------:|:----------------------:|
| malloc                |                                                                                                                                                             Memory is dynamically allocated                                                                                                                                                            |                                  void *memset(void *s, int c, size_t n);                                 |   #include <stdlib.h>  |
| free                  |                                                                                                                                      Remove previously allocated memory such as `malloc` or `calloc` or `realloc`                                                                                                                                      |                                           void free(void *ptr)                                           |   #include <stdlib.h>  |
| write                 |                                                                                                                                           write up to count bytes from the buffer starting at buf to the file                                                                                                                                          |                             ssize_t write(int fd, const void *buf, size_t n)                             |   #include <unistd.h>  |
| usleep                |                                                                                                                                                       Wait for a specified number of microseconds                                                                                                                                                      |                                    int usleep(useconds_t microseconds)                                   |   #include <unistd.h>  |
| gettimeofday          |                                                                                                                                Obtains the current time,since January 1, 1970, and stores it in the `timeval` structure                                                                                                                                |                     int gettimeofday(struct timeval *restrict tp, void *restrict tzp)                    |  #include <sys/time.h> |
| pthread_create        |                                                                                                                                                                     Create a thread                                                                                                                                                                    | pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg) |  #include <pthread.h>  |
| pthread_detach        |                                                                                                                                                                Isolate a specific thread                                                                                                                                                               |                                   int pthread_detach(pthread_t thread)                                   |  #include <pthread.h>  |
| pthread_join          |                                                                                                                          Waiting for a specific thread to exit. The joined thread (thread terminated) releases all resources.                                                                                                                          |                           int pthread_join(pthread_t thread, void **value_ptr)                           |  #include <pthread.h>  |
| pthread_mutex_init    |                                                                                                                                                                     Create a mutex                                                                                                                                                                     |              int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)             |  #include <pthread.h>  |
| pthread_mutex_destroy |                                                                                                                                                         Releases (returns) the allocated mutex.                                                                                                                                                        |                             int pthread_mutex_destroy(pthread_mutex_t *mutex)                            |  #include <pthread.h>  |
| pthread_mutex_lock    |                                                                                                                   (start critical section). Lock the mutex. If already locked, the calling thread blocks until a mutex is available.                                                                                                                   |                              int pthread_mutex_lock(pthread_mutex_t *mutex)                              |  #include <pthread.h>  |
| fork                  |                                                                                                                                                Creates a copy process for the currently running process.                                                                                                                                               |                                             pid_t fork(void)                                             |   #include <unistd.h>  |
| kill                  |                                                                                              Unlike the kill command, which kills a process in the shell, it sends a signal to the process. Sending `SIGKILL` to a process acts like a shell command kill.                                                                                             |                                       int kill(pid_t pid, int sig)                                       |   #include <signal.h>  |
| exit                  |                                                                                                                                                                 Terminate the process.                                                                                                                                                                 |                                           void exit(int status)                                          |   #include <stdlib.h>  |
| waitpid               |                                                      `wait()` like a function, it waits until the child process exits. The difference is that the `wait()` function is released from the wait when any of the child processes exit, but waits `waitpid()` until the specific child process exits.                                                      |                            pid_t waitpid(pid_t pid, int *status, int options)                            |  #include <sys/wait.h> |
| sem_open              |                                                                                                                                                       Function to initialize and open a semaphore                                                                                                                                                      |                             sem_t *sem_open(const char *name, int oflag, ...)                            | #include <semaphore.h> |
| sem_close             |                                                                                                                  The semaphore is unlocked, the semaphore value is incremented, and all threads waiting on the semaphore are woken up.                                                                                                                 |                                         int sem_post(sem_t *sem)                                         | #include <semaphore.h> |
| sem_post              |                                                                                                                  The semaphore is unlocked, the semaphore value is incremented, and all threads waiting on the semaphore are woken up.                                                                                                                 |                                         int sem_post(sem_t *sem)                                         | #include <semaphore.h> |
| sem_wait              |                                     Lock the semaphore. If the current semaphore value is 0, the calling thread does `sem_wait()` not return until the call is aborted by a signal or locking the semaphore . If executed successfully, the `sem_post()` lock state is maintained until the lock is released with .                                    |                                         int sem_wait(sem_t *sem)                                         | #include <semaphore.h> |
| sem_unlink            | Removes a named semaphore. If the current semaphore named by name is being referenced by any process, this function has no effect on that semaphore. If more than one process calls this function and the semaphore is open, `sem_close()` the removal of the semaphore is deferred until all referenced semaphores have been terminated, for example. |                                     int sem_unlink(const char *name)                                     | #include <semaphore.h> |

## Diffrence between mutex and semaphore
----
Mutex and Semaphore are both techniques designed to acheive mutual exclusion of shared resources. In other words, it is the biggest task of concurrent programming, a method for controlling (management) access to shared resources by multiple processes or threads, and uses different methods as follows.

### Mutex
`Mutex`is mutual exclusion technique based on object owned by a thread. The term "mutex" comes from "MUTual EXclusion", which perfectly describes its purpose. In short, a mutex makes it possible to ensure that only one thread at a time has access to the object. A popular real-life example of a mutex involves toilets. When a person enters a toilet partition, he locks the door from the inside. The toilet is like an object that can be accessed by multiple threads. The lock on the partition door is like a mutex, and the line of people outside represents threads. The lock on the door is the toilet's mutex: it ensures that only one person can get inside.

In other words, only one thread at a time can work with shared resources. Attempts by other threads (people) to gain access to occupied resources will fail. A mutex has several important features. 

### Semaphore
`Semaphore`is mutual exclusion technique in which a counting variable value indicating the number of threads that can access the current shared resource is placed. Its distinctive feature is that it uses a counter to create the synchronization mechanism. The counter tells us how many threads can simultaneously access the shared resource. 

Semaphores are non-negative integer values that support the operations semaphore->P() and semaphore->V(). P is an atomic operation that waits for a semaphore to be positive and then decrements it by one, while V is an atomic operation that increments a semaphore by one, which implies it wakes up a waiting P. Test and set associated with semaphore are routines implemented in hardware to coordinate lower-level critical sections.

Semaphores are normally implemented using file descriptors. Semaphore creations are not atomic. If two processes try to create, initialize and use a semaphore at the same time, a race condition is created. Semaphores are created and initialized to a positive value to show the availability of a resource to be used. Semaphores can be implemented through interrupts or by using test-set operations.

Every semaphore maintains sets of permits. It restricts the number of threads accessing the resources. Semaphores with only one permit and initialized to one serve as mutual exclusion locks. They are referred to as such because they have only two states: permit available or zero permit available. This encloses the property so that a lock can be released by a thread other than the owner, helping in deadlock recovery. Semaphores are used for mutual exclusions where the semaphore has an initial value of one, and P () and V () are called before and after the critical sections.

## Deadlock
---
If the cars go straight at almost the same time, as shown at the right, each car has a resource and needs another resource (a, b, c, d), and thus a deadlock occurs.

![](https://miro.medium.com/max/1400/1*mdFN-uFWVcwP9Ur9P5NV_w.png)

Deadlock can exist if and only if 4 conditions hold simultaneously:

1. **Mutual exclusion**
 	Only one process can use the resource at a time. That is, resources occupied by one process cannot be accessed by other processes.
<br/>
1. **Hold and wait**
	A process that already has a resource is waiting for another resource requesting it.
<br/>
1. **No preemption**
	Another process cannot forcibly seize the resources occupied by the process.
<br/>
1. **Circular wait**
   A closed chain exists between processes. That is, an annulus is created in the resource-allocation graph. In a closed connection, a blocked process occupies a resource, and another process in the chain wants this resource and is waiting.

mutual exclusion is absolutely necessary to ensure the consistency of execution results and the integrity of the database. Condition 4 occurs as a result of conditions 1-3. That is, as a result of the complex interaction of conditions 1 to 3, an unsolvable condition occurs. The definition of a deadlock is an annular waiting state that cannot be resolved immediately. The reason why the annular wait state cannot be resolved is that conditions 1 to 3 are observed. After all, the above four conditions are necessary and sufficient conditions for a deadlock to occur.

Among the various approaches to solving the deadlock, there are three representative ones.
The first approach is to prevent the system from allowing one of the conditions 1 to 4 for deadlock to occur.
The second approach is to safely determine resource allocation according to the current resource allocation status as deadlock avoidance.
A third approach is deadlock detection, which detects and recovers from deadlocks when they occur. Now let's look at each method.

### Deadlock Prevention

A deadlock prevention strategy is to eliminate the possibility of deadlocks when designing an operating system, but mutual exclusion conditions cannot be eliminated when designing a system. Since the mutual exclusion condition is absolutely necessary to maintain the consistency of shared resources, if mutual exclusion is required in resource access, the operating system must support it. For example, for a resource such as a file, multiple read accesses are allowed, but only one write access should be allowed exclusively at a time. A deadlock can also occur when multiple processes are trying to gain write access.

### Deadlock Avoidance

Another way to solve deadlocks is avoidance. Avoidance takes a slightly different approach than prevention. Deadlock prevention is a method of preventing one of the four conditions necessary for deadlock to occur. Prevention can lead to inefficiencies in resource usage and process performance. On the other hand, deadlock avoidance allows 1-3 of the deadlock occurrence conditions. Nor does it predetermine the order of resource allocation like prevention. Instead, when allocating resources, consider not going into a situation where a deadlock is possible. Therefore, the avoidance method provides more parallelism than the prevention method (higher efficiency of resource use).

### Deadlock Detection

The deadlock prevention strategy places restrictions on resource access and process execution to prevent deadlocks from occurring. On the other hand, the deadlock detection strategy does not impose restrictions on resource access or process behavior. That is, if resource allocation is possible, it always allocates it. However, the deadlock detection method periodically checks whethe! r an annular waiting condition has occurred in the system and, if it does, resolves it.# philosopher
